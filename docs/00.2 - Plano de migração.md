# üìã Plano de Migra√ß√£o: Prisma ‚Üí TypeORM + Oracle

## üéØ **Objetivo**

Migrar de uma arquitetura baseada em Prisma + API do ERP para TypeORM + consultas SQL diretas no Oracle, mantendo PostgreSQL como cache rico.

---

## üìä **An√°lise do Estado Atual**

### **Depend√™ncias Atuais**

```json
"dependencies": {
  "@prisma/client": "^6.5.0",
  // ... outras deps
}
"devDependencies": {
  "prisma": "^6.5.0",
  // ... outras deps
}
```

### **Estrutura Atual**

```
packages/api/src/
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ env.schema.ts
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îî‚îÄ‚îÄ prisma.ts
‚îú‚îÄ‚îÄ plugins/ (JWT, Auth, CORS, etc.)
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îî‚îÄ‚îÄ auth.ts
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ fastify.d.ts
‚îî‚îÄ‚îÄ server.ts

prisma/
‚îú‚îÄ‚îÄ schema.prisma
‚îú‚îÄ‚îÄ migrations/
‚îî‚îÄ‚îÄ migration_lock.toml
```

### **Modelos Atuais (Prisma)**

- `User` (id, username, passwordHash, name, role, timestamps)
- `Payment` (id, amount, currency, payee, description, status, dueDate, relacionamentos)
- Enums: `UserRole`, `PaymentStatus`

---

## üîÑ **Fases da Migra√ß√£o**

### **FASE 1: Prepara√ß√£o e Setup Dual Database**

**Dura√ß√£o estimada:** 2-3 dias

#### **1.1. Depend√™ncias**

- ‚ùå **Remover:** `@prisma/client`, `prisma`
- ‚úÖ **Adicionar:** `typeorm`, `oracledb`, `pg` (drivers)
- ‚úÖ **Adicionar:** `@types/oracledb` (dev)

#### **1.2. Configura√ß√£o de Ambiente** (Oracle GLOBUS REAL)

- ‚úÖ **Adicionar vari√°veis:**

  ```env
  # PostgreSQL (existente)
  DATABASE_URL="postgresql://..."

  # Oracle ERP GLOBUS (novo)
  ORACLE_HOST=your_oracle_host
  ORACLE_PORT=1521
  ORACLE_SERVICE_NAME=GLOBUS
  ORACLE_USERNAME=your_username
  ORACLE_PASSWORD=your_password
  ORACLE_SCHEMA=GLOBUS

  # Sincroniza√ß√£o
  SYNC_INTERVAL_MINUTES=15
  SYNC_BATCH_SIZE=1000

  # Performance
  ORACLE_POOL_MIN=2
  ORACLE_POOL_MAX=10
  ORACLE_TIMEOUT=30000
  ```

#### **1.3. Estrutura de Pastas**

```
packages/api/src/
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ env.schema.ts (atualizar)
‚îÇ   ‚îú‚îÄ‚îÄ database.config.ts (novo)
‚îÇ   ‚îî‚îÄ‚îÄ datasources.ts (novo - conex√µes duplas)
‚îú‚îÄ‚îÄ entities/ (novo)
‚îÇ   ‚îú‚îÄ‚îÄ postgresql/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ User.entity.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Payment.entity.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ PaymentComment.entity.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Attachment.entity.ts
‚îÇ   ‚îî‚îÄ‚îÄ oracle/
‚îÇ       ‚îú‚îÄ‚îÄ ErpPayment.entity.ts
‚îÇ       ‚îú‚îÄ‚îÄ ErpSupplier.entity.ts
‚îÇ       ‚îî‚îÄ‚îÄ ErpUser.entity.ts
‚îú‚îÄ‚îÄ lib/
‚îÇ   ‚îú‚îÄ‚îÄ typeorm.ts (substituir prisma.ts)
‚îÇ   ‚îî‚îÄ‚îÄ hash.ts (manter)
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îú‚îÄ‚îÄ etl/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sync.service.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data-mapper.service.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation.service.ts
‚îÇ   ‚îú‚îÄ‚îÄ payment.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ user.service.ts
‚îú‚îÄ‚îÄ jobs/ (novo)
‚îÇ   ‚îú‚îÄ‚îÄ sync-job.ts
‚îÇ   ‚îî‚îÄ‚îÄ job-scheduler.ts
‚îú‚îÄ‚îÄ migrations/ (novo - TypeORM)
‚îÇ   ‚îî‚îÄ‚îÄ postgresql/
‚îî‚îÄ‚îÄ utils/
    ‚îú‚îÄ‚îÄ oracle-helpers.ts
    ‚îî‚îÄ‚îÄ data-transformation.ts
```

---

### **FASE 2: Configura√ß√£o TypeORM e Conex√µes**

**Dura√ß√£o estimada:** 1-2 dias

#### **2.1. DataSources TypeORM** (configura√ß√£o REAL)

```typescript
// config/datasources.ts
export const PostgreSQLDataSource = new DataSource({
  type: 'postgres',
  url: process.env.DATABASE_URL,
  entities: ['./entities/postgresql/*.entity.ts'],
  migrations: ['./migrations/postgresql/*.ts'],
  synchronize: false,
  logging: process.env.NODE_ENV === 'development',
});

export const OracleDataSource = new DataSource({
  type: 'oracle',
  host: process.env.ORACLE_HOST,
  port: parseInt(process.env.ORACLE_PORT || '1521'),
  serviceName: process.env.ORACLE_SERVICE_NAME, // GLOBUS
  username: process.env.ORACLE_USERNAME,
  password: process.env.ORACLE_PASSWORD,
  schema: process.env.ORACLE_SCHEMA || 'GLOBUS',
  entities: ['./entities/oracle/*.entity.ts'],
  synchronize: false, // NUNCA true para Oracle de produ√ß√£o
  logging: false, // Oracle pode ter logs verbosos
  extra: {
    // Configura√ß√µes espec√≠ficas Oracle
    connectString: `${process.env.ORACLE_HOST}:${process.env.ORACLE_PORT}/${process.env.ORACLE_SERVICE_NAME}`,
    poolMin: parseInt(process.env.ORACLE_POOL_MIN || '2'),
    poolMax: parseInt(process.env.ORACLE_POOL_MAX || '10'),
    poolTimeout: parseInt(process.env.ORACLE_TIMEOUT || '30000'),
    // Configura√ß√µes para BLOB (anexos)
    fetchAsString: [],
    fetchAsBuffer: ['BLOB'],
  },
});
```

#### **2.2. Conex√£o no Fastify**

```typescript
// lib/typeorm.ts
import { PostgreSQLDataSource, OracleDataSource } from '../config/datasources';

export let pgDataSource: DataSource;
export let oracleDataSource: DataSource;

export async function initializeDatabases() {
  pgDataSource = await PostgreSQLDataSource.initialize();
  oracleDataSource = await OracleDataSource.initialize();
}
```

---

### **FASE 3: Convers√£o de Entidades**

**Dura√ß√£o estimada:** 2 dias

#### **3.1. Entidades PostgreSQL** (baseadas no Prisma atual)

```typescript
// entities/postgresql/User.entity.ts
@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  username: string;

  @Column()
  passwordHash: string;

  @Column()
  name: string;

  @Column({ type: 'enum', enum: UserRole, default: UserRole.REQUESTER })
  role: UserRole;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  // Relacionamentos
  @OneToMany(() => Payment, (payment) => payment.requester)
  paymentsRequested: Payment[];
}
```

#### **3.2. Entidades Oracle** (estrutura ERP REAL)

```typescript
// entities/oracle/ErpPayment.entity.ts
@Entity('CPGDOCTO') // Schema GLOBUS.CPGDOCTO
export class ErpPayment {
  @PrimaryColumn({ name: 'CODDOCTOCPG' })
  erp_payment_id: number;

  @Column({ name: 'USUARIO', length: 15 })
  requester_username: string;

  @Column({ name: 'DATA_INCLUSAO' })
  created_date: Date;

  @Column({ name: 'VENCIMENTOCPG' })
  due_date: Date;

  @Column({ name: 'STATUSDOCTOCPG', length: 1 })
  erp_status: string; // B, N, C

  @Column({ name: 'QUITADODOCTOCPG', length: 1 })
  is_paid: string; // S, N

  @Column({ name: 'PAGAMENTOLIBERADO', length: 1 })
  payment_approved: string; // S, N

  @Column({ name: 'NRODOCTOCPG', length: 10 })
  document_number: string;

  @Column({ name: 'FAVORECIDODOCTOCPG', length: 200 })
  payee_name: string;

  @Column({ name: 'CODIGOFORN' })
  supplier_id: number;

  @Column({ name: 'VLR_ORIGINAL', type: 'decimal', precision: 22, scale: 2 })
  original_value: number;

  // Relacionamentos
  @OneToMany(() => ErpPaymentHistory, (history) => history.payment)
  history: ErpPaymentHistory[];

  @OneToMany(() => ErpAttachment, (attachment) => attachment.payment)
  attachments: ErpAttachment[];

  @ManyToOne(() => ErpSupplier, (supplier) => supplier.payments)
  @JoinColumn({ name: 'CODIGOFORN' })
  supplier: ErpSupplier;
}

// entities/oracle/ErpPaymentHistory.entity.ts
@Entity('CPGDOCTO_HISTORICO_NEGOCIACOES')
export class ErpPaymentHistory {
  @PrimaryColumn({ name: 'CODDOCTOCPG' })
  erp_payment_id: number;

  @PrimaryColumn({ name: 'SEQUENCIA_EVENTO' })
  sequence_number: number;

  @Column({ name: 'DATA_EVENTO' })
  event_date: Date;

  @Column({ name: 'USUARIO', length: 15 })
  action_user: string;

  @Column({ name: 'VLR_BRUTO', type: 'decimal', precision: 22, scale: 2 })
  amount_at_time: number; // VALOR REAL aqui!

  @Column({ name: 'MAIS_INFORMACOES', length: 500 })
  comment: string;

  @ManyToOne(() => ErpPayment, (payment) => payment.history)
  @JoinColumn({ name: 'CODDOCTOCPG' })
  payment: ErpPayment;
}

// entities/oracle/ErpSupplier.entity.ts
@Entity('BGM_FORNECEDOR')
export class ErpSupplier {
  @PrimaryColumn({ name: 'CODIGOFORN' })
  supplier_id: number;

  @Column({ name: 'NFANTASIAFORN', length: 100 })
  supplier_name: string;

  @Column({ name: 'SITUACAO', length: 1 })
  status: string;

  @OneToMany(() => ErpPayment, (payment) => payment.supplier)
  payments: ErpPayment[];
}

// entities/oracle/ErpUser.entity.ts
@Entity('CTR_CADASTRODEUSUARIOS')
export class ErpUser {
  @PrimaryColumn({ name: 'USUARIO', length: 15 })
  username: string;

  @Column({ name: 'NOMEUSUARIO', length: 40 })
  name: string;

  @Column({ name: 'EMAIL', length: 50 })
  email: string;

  @Column({ name: 'ATIVO', length: 1 })
  is_active: string; // S, N
}

// entities/oracle/ErpAttachment.entity.ts
@Entity('CPGDOCTO_ANEXO')
export class ErpAttachment {
  @PrimaryColumn({ name: 'ID' })
  attachment_id: number;

  @Column({ name: 'CODDOCTOCPG' })
  erp_payment_id: number;

  @Column({ name: 'NOME', length: 200 })
  filename: string;

  @Column({ name: 'DATA' })
  upload_date: Date;

  @Column({ name: 'ARQUIVO', type: 'blob' })
  file_content: Buffer;

  @ManyToOne(() => ErpPayment, (payment) => payment.attachments)
  @JoinColumn({ name: 'CODDOCTOCPG' })
  payment: ErpPayment;
}
```

---

### **FASE 4: Sistema ETL/Sincroniza√ß√£o**

**Dura√ß√£o estimada:** 3-4 dias

#### **4.1. Servi√ßo de Sincroniza√ß√£o** (com dados REAIS)

```typescript
// services/etl/sync.service.ts
export class SyncService {
  async syncNewPayments(): Promise<void> {
    // 1. Consultar Oracle por novas APs (consulta REAL validada)
    const newErpPayments = await this.getNewErpPayments();

    // 2. Transformar dados Oracle ‚Üí PostgreSQL
    const transformedPayments = await this.transformPayments(newErpPayments);

    // 3. Salvar no PostgreSQL com dados completos
    await this.saveToPostgreSQL(transformedPayments);
  }

  private async getNewErpPayments() {
    return await oracleDataSource
      .createQueryBuilder()
      .select([
        'c.CODDOCTOCPG as erp_payment_id',
        'c.USUARIO as requester_username',
        'c.DATA_INCLUSAO as created_date',
        'c.VENCIMENTOCPG as due_date',
        'c.STATUSDOCTOCPG as erp_status',
        'c.QUITADODOCTOCPG as is_paid',
        'c.PAGAMENTOLIBERADO as payment_approved',
        'c.NRODOCTOCPG as document_number',
        'c.FAVORECIDODOCTOCPG as payee_name',
        'c.CODIGOFORN as supplier_id',
        'c.VLR_ORIGINAL as original_value',
        'f.NFANTASIAFORN as supplier_name',
        'u.NOMEUSUARIO as requester_name',
        'u.EMAIL as requester_email',
        // Buscar valor real do hist√≥rico
        'h.VLR_BRUTO as real_amount',
      ])
      .from('GLOBUS.CPGDOCTO', 'c')
      .leftJoin('GLOBUS.BGM_FORNECEDOR', 'f', 'f.CODIGOFORN = c.CODIGOFORN')
      .leftJoin('GLOBUS.CTR_CADASTRODEUSUARIOS', 'u', 'u.USUARIO = c.USUARIO')
      .leftJoin(
        // Subquery para pegar o valor mais recente do hist√≥rico
        `(SELECT h2.CODDOCTOCPG, 
                 FIRST_VALUE(h2.VLR_BRUTO) OVER (
                   PARTITION BY h2.CODDOCTOCPG 
                   ORDER BY h2.DATA_EVENTO DESC, h2.SEQUENCIA_EVENTO DESC
                   ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
                 ) as VLR_BRUTO
          FROM GLOBUS.CPGDOCTO_HISTORICO_NEGOCIACOES h2
          WHERE h2.VLR_BRUTO > 0)`,
        'h',
        'h.CODDOCTOCPG = c.CODDOCTOCPG'
      )
      .where('c.DATA_INCLUSAO > :lastSync', {
        lastSync: this.getLastSyncTime(),
      })
      .andWhere('c.STATUSDOCTOCPG IN (:...validStatuses)', {
        validStatuses: ['B', 'N'], // Bloqueado ou Novo
      })
      .getRawMany();
  }

  private async transformPayments(erpPayments: any[]) {
    return erpPayments.map((erp) => ({
      erp_payment_id: erp.erp_payment_id,
      requester_username: erp.requester_username,
      requester_name: erp.requester_name,
      requester_email: erp.requester_email,
      created_date: erp.created_date,
      due_date: erp.due_date,

      // L√≥gica de status mapeada
      internal_status: this.mapErpStatus(
        erp.erp_status,
        erp.is_paid,
        erp.payment_approved
      ),

      // Valor total (prioridade para VLR_BRUTO do hist√≥rico)
      total_amount: erp.real_amount || erp.original_value || 0,

      document_number: erp.document_number,
      payee_name: erp.payee_name,
      supplier_id: erp.supplier_id,
      supplier_name: erp.supplier_name,

      // Metadados completos em JSON para backup
      erp_metadata: {
        original_status: erp.erp_status,
        is_paid: erp.is_paid,
        payment_approved: erp.payment_approved,
        original_value: erp.original_value,
        sync_timestamp: new Date(),
      },

      // Controle de freshness
      last_oracle_sync: new Date(),
      oracle_available: true,
      can_operate_offline: true,
      critical_data_complete: true,
    }));
  }

  private mapErpStatus(
    status: string,
    isPaid: string,
    isApproved: string
  ): string {
    if (status === 'B' && isPaid === 'S') return 'PAID';
    if (status === 'B' && isApproved === 'S') return 'APPROVED';
    if (status === 'B') return 'PENDING';
    if (status === 'C') return 'CANCELLED';
    if (status === 'N') return 'NEW';
    return 'UNKNOWN';
  }
}
```

#### **4.2. Jobs Automatizados**

```typescript
// jobs/sync-job.ts
export class SyncJob {
  private interval: NodeJS.Timeout;

  start() {
    const intervalMs = (process.env.SYNC_INTERVAL_MINUTES || 15) * 60 * 1000;
    this.interval = setInterval(async () => {
      await this.runSync();
    }, intervalMs);
  }

  private async runSync() {
    try {
      const syncService = new SyncService();
      await syncService.syncNewPayments();
      console.log('Sync completed successfully');
    } catch (error) {
      console.error('Sync failed:', error);
    }
  }
}
```

---

### **FASE 5: Migra√ß√£o de Servi√ßos e Rotas**

**Dura√ß√£o estimada:** 2-3 dias

#### **5.1. Atualizar Routes**

```typescript
// routes/auth.ts (exemplo de migra√ß√£o)
export default async function authRoutes(server: FastifyInstance) {
  server.post('/login', async (request, reply) => {
    const { username, password } = request.body;

    // Trocar prisma.user por TypeORM
    const userRepo = pgDataSource.getRepository(User);
    const user = await userRepo.findOne({
      where: { username },
    });

    // Resto da l√≥gica permanece igual
  });
}
```

#### **5.2. Novos Servi√ßos**

```typescript
// services/payment.service.ts
export class PaymentService {
  private pgPaymentRepo = pgDataSource.getRepository(Payment);
  private oraclePaymentRepo = oracleDataSource.getRepository(ErpPayment);

  async getPaymentDetails(id: string) {
    // Buscar dados cached no PostgreSQL
    const payment = await this.pgPaymentRepo.findOne({
      where: { id },
      relations: ['requester', 'comments', 'attachments'],
    });

    // Se necess√°rio, consultar Oracle para dados mais recentes
    if (payment?.erpPaymentId) {
      const erpData = await this.oraclePaymentRepo.findOne({
        where: { ID_REQUISICAO: payment.erpPaymentId },
      });
      // Merge ou valida√ß√£o de dados
    }

    return payment;
  }
}
```

---

### **FASE 6: Migra√ß√£o de Dados e Testes**

**Dura√ß√£o estimada:** 2 dias

#### **6.1. Migra√ß√£o TypeORM**

```typescript
// migrations/postgresql/0001-CreateInitialTables.ts
export class CreateInitialTables1234567890 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    // Criar tabelas baseadas nas entidades atuais do Prisma
    await queryRunner.query(`
      CREATE TYPE "UserRole" AS ENUM ('REQUESTER', 'DIRECTOR');
      CREATE TYPE "PaymentStatus" AS ENUM ('PENDING', 'APPROVED', 'REJECTED', 'CANCELLED');
    `);

    // Tabelas users, payments, etc.
  }
}
```

#### **6.2. Migra√ß√£o de Dados Existentes**

```typescript
// utils/migrate-existing-data.ts
export async function migrateFromPrisma() {
  // Script para migrar dados existentes do formato Prisma para TypeORM
  // (se houver dados em produ√ß√£o)
}
```

---

### **FASE 7: Atualiza√ß√£o de Documenta√ß√£o e Cleanup**

**Dura√ß√£o estimada:** 1 dia

#### **7.1. Cleanup**

- ‚ùå Remover pasta `prisma/`
- ‚ùå Remover `lib/prisma.ts`
- ‚ùå Atualizar `package.json` scripts
- ‚ùå Remover depend√™ncias Prisma

#### **7.2. Documenta√ß√£o**

- ‚úÖ Atualizar README.md
- ‚úÖ Atualizar documenta√ß√£o de arquitetura
- ‚úÖ Documentar processo de sync
- ‚úÖ Documentar conex√µes Oracle

---

## ‚ö†Ô∏è **Riscos e Considera√ß√µes**

### **Alto Risco**

1. **Conex√£o Oracle:** Configura√ß√£o de rede, firewall, credenciais
2. **Volume de Dados:** 856K+ documentos, 1.4M+ eventos de hist√≥rico
3. **Performance:** Oracle com 6GB+ de dados BLOB (anexos)
4. **Encoding:** Problemas de charset Oracle vs PostgreSQL

### **‚úÖ RESOLVIDO: Schema Oracle**

**Schema GLOBUS mapeado completamente:**

- `GLOBUS.CPGDOCTO` (856.607 registros)
- `GLOBUS.CPGDOCTO_HISTORICO_NEGOCIACOES` (1.287.583 registros)
- `GLOBUS.CPGDOCTO_ANEXO` (2.097 registros BLOB)
- `GLOBUS.BGM_FORNECEDOR` (3.980 registros)
- `GLOBUS.CTR_CADASTRODEUSUARIOS` (865 registros)

### **M√©dio Risco**

1. **Sincroniza√ß√£o:** Perda de dados durante sync
2. **Downtime:** Migra√ß√£o pode afetar opera√ß√£o
3. **Compatibilidade:** Diferen√ßas TypeORM vs Prisma

### **Mitiga√ß√µes**

1. **Ambiente de testes** espelhando produ√ß√£o
2. **Rollback plan** mantendo Prisma temporariamente
3. **Monitoramento** de sync e performance
4. **Logs detalhados** para debugging

---

## üìà **Cronograma Resumido**

| Fase | Dura√ß√£o  | Descri√ß√£o             |
| ---- | -------- | --------------------- |
| 1    | 2-3 dias | Setup dual database   |
| 2    | 1-2 dias | Configura√ß√£o TypeORM  |
| 3    | 2 dias   | Convers√£o entidades   |
| 4    | 3-4 dias | Sistema ETL           |
| 5    | 2-3 dias | Migra√ß√£o servi√ßos     |
| 6    | 2 dias   | Migra√ß√£o dados/testes |
| 7    | 1 dia    | Cleanup/documenta√ß√£o  |

**Total estimado:** 13-19 dias (2.5-4 semanas)

---

## ‚úÖ **Pr√≥ximos Passos Imediatos**

1. ‚úÖ **~~Validar estrutura Oracle ERP~~** - ‚úÖ **CONCLU√çDO!** Schema GLOBUS mapeado
2. **Configurar ambiente de testes** com Oracle GLOBUS dispon√≠vel
3. **Decidir estrat√©gia de rollback** - manter Prisma em paralelo temporariamente?
4. **Definir janela de migra√ß√£o** - quando fazer a transi√ß√£o em produ√ß√£o?
5. **Implementar FASE 1** - Setup dual database com as configura√ß√µes reais Oracle

**üéØ RECOMENDA√á√ÉO:** Come√ßar com FASE 1 agora que temos o schema Oracle completo!
